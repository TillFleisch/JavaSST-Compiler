package dev.fleisch.JSSTCompiler.ByteCodeGenerator;

import dev.fleisch.JSSTCompiler.*;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.LinkedList;

/**
 * Class implementing procedure translation into bytecode
 *
 * @author TillFleisch
 */
public class ProcedureTranslator {

    /**
     * List of local variables used within this method
     */
    private final LinkedList<Objekt.Parameter> localVariableIndices = new LinkedList<>();

    /**
     * Class-constant pool
     */
    private final ConstantPool constantPool;

    /**
     * Bytecode generated by this Translator
     */
    private final byte[] bytecode;

    /**
     * Maximum nr of local variables used by this method
     */
    private final int maxLocals;

    /**
     * Maximum stack size during execution of this procedure
     */
    private int maxStack = 0;

    /**
     * Current stack size used during bytecode generation.
     */
    private int stackSize = 0;

    /**
     * Creates a Procedure Translator and translates the procedures AST into equiavalent bytecode
     *
     * @param constantPool Constant pool provided by the class containing this mehtod
     * @param procedure    The procedure to translate
     * @throws Exception If translation fails
     */
    public ProcedureTranslator(ConstantPool constantPool, Objekt.Procedure procedure) throws Exception {
        this.constantPool = constantPool;

        // Find all variables within the symbol table
        for (Objekt objekt : procedure.getSymbolTable()) {
            if (objekt instanceof Objekt.Parameter) {
                localVariableIndices.add((Objekt.Parameter) objekt);
            }
        }

        // Determine how many local variables exist (+1 object reference)
        maxLocals = procedure.getParameterList().size() + localVariableIndices.size() + 1;

        // Translate procedure AST into bytecode recursively
        bytecode = toByteCode(procedure.getAbstractSyntaxTree());

        // Assert that the stack is empty
        if (stackSize != 0)
            throw new Exception("Procedure leaves without emptying the stack!");
    }

    /**
     * Increments the stacks size counter by i and updates maxStack accordingly
     *
     * @param i Amount to increment by
     * @throws Exception If the stack size exceeds the maximum stack size
     */
    private void incrementStackSize(int i) throws Exception {
        stackSize += i;
        if (stackSize > maxStack)
            maxStack = stackSize;
        if (stackSize > 0xFFFF)
            throw new Exception("Maximum Stack size exceeded!");
    }

    /**
     * Decrements the stack size
     *
     * @param i Amount to decrement by
     * @throws Exception If the stack size reaches negative values
     */
    private void decrementStackSize(int i) throws Exception {
        incrementStackSize(-i);
        if (stackSize < 0)
            throw new Exception("Stack underflow, invalid code generation!");
    }

    /**
     * The bytecode generated by this Procedure Translator
     *
     * @return Bytecode representing the procedures content
     */
    public byte[] getBytecode() {
        return bytecode;
    }

    /**
     * Highest number of local variables during execution
     *
     * @return max. number of variables used during execution
     */
    public int getMaxLocals() {
        return maxLocals;
    }

    /**
     * Reruns the largest stack size used during execution
     *
     * @return Largest stack size used during execution
     */
    public int getMaxStack() {
        return maxStack;
    }

    /**
     * Translates an expression given by an AST into ByteCode
     *
     * @param node Expression to translate
     * @return Equivalent ByteCode
     */
    private byte[] toByteCode(Node node) throws Exception {
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();

        // Translate sequences
        if (node instanceof Node.StatementSequenceNode) {
            Node.StatementSequenceNode statementSequenceNode = (Node.StatementSequenceNode) node;
            ByteArrayOutputStream sequenceStream = new ByteArrayOutputStream();

            // go through all statements and translate them
            for (Node statement : statementSequenceNode.getStatements()) {
                // Translate statement
                sequenceStream.write(toByteCode(statement));

                if(statement instanceof Node.ProcedureCallNode){
                    Objekt.Procedure procedure = (Objekt.Procedure) ((Node.ProcedureCallNode)statement).getSymbolTableEntry();
                    // Method returns value but value is not used
                    if(procedure.getReturnType()!=Type.VOID){
                        decrementStackSize(1);
                    }
                }
            }

            // Write statements to output
            outputStream.write(sequenceStream.toByteArray());

            return outputStream.toByteArray();
        }

        // Translate unary operations
        if (node instanceof Node.UnaryOperationNode) {
            Node.UnaryOperationNode unaryOperationNode = (Node.UnaryOperationNode) node;

            // Translate return statements
            if (unaryOperationNode.getOperation() == Operation.Unary.RETURN) {
                if (unaryOperationNode.getLeft() == null) {
                    // Return void
                    outputStream.write(ByteCode.RETURN.getCode());
                } else {
                    // Return parameter int (load int recursively)
                    outputStream.write(toByteCode(unaryOperationNode.getLeft()));
                    // Return value
                    outputStream.write(ByteCode.IRETURN.getCode());
                    decrementStackSize(1);
                }
            }
            return outputStream.toByteArray();
        }

        // Translate constant values
        if (node instanceof Node.ConstantNode) {
            Node.ConstantNode constantNode = (Node.ConstantNode) node;

            incrementStackSize(1);
            return loadConstant(constantNode.getValue());
        }

        // Translate identifiers (load operations)
        if (node instanceof Node.IdentifierNode) {
            return toByteCode((Node.IdentifierNode) node);
        }

        // Translate binary operation Nodes
        if (node instanceof Node.BinaryOperationNode) {
            return toByteCode((Node.BinaryOperationNode) node);
        }

        // Translate if/else statements
        if (node instanceof Node.IfNode) {
            return toByteCode((Node.IfNode) node);
        }

        // Translate while node
        if (node instanceof Node.WhileNode) {
            return toByteCode((Node.WhileNode) node);
        }

        // Translate procedure calls
        if (node instanceof Node.ProcedureCallNode) {
            return toByteCode((Node.ProcedureCallNode) node);
        }

        throw new UnsupportedOperationException(String.valueOf(node.getClass()));
    }

    /**
     * Translates a procedureCallNode into ByteCode
     *
     * @param procedureCallNode ProcedureCallNode to translate
     * @return ByteCode representing the procedureCall node and subsequent nodes
     * @throws IOException on translations failure
     */
    private byte[] toByteCode(Node.ProcedureCallNode procedureCallNode) throws Exception {
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();

        Node.StatementSequenceNode parameters = (Node.StatementSequenceNode) procedureCallNode.getLeft();

        // Load object reference
        outputStream.write(ByteCode.ALOAD_0.getCode());
        incrementStackSize(1);

        // Translate all parameters and leave them on the stack
        for (Node statement : parameters.getStatements()) {
            // Implicitly also adds parameters to the stack counter
            outputStream.write(toByteCode(statement));
        }

        Objekt.Procedure symbolTableEntry = (Objekt.Procedure) procedureCallNode.getSymbolTableEntry();

        // Write invoke (find index in constant Pool)
        // Constructor requires special call
        outputStream.write(procedureCallNode.getSymbolTableEntry().getName().contains("init")
                ? ByteCode.INVOKESPECIAL.getCode()
                : ByteCode.INVOKEVIRTUAL.getCode());
        short methodIndex = (short) constantPool.getByReference(symbolTableEntry);
        outputStream.write(methodIndex >> 8);
        outputStream.write(methodIndex);

        // Remove nr. of parameters from the stack counter (+ 1 aload)
        decrementStackSize(parameters.getStatements().size() + 1);

        // Add return value to stack if it does return a value
        incrementStackSize(symbolTableEntry.getReturnType() == Type.VOID ? 0 : 1);

        return outputStream.toByteArray();
    }

    /**
     * Translates a whileNode into ByteCode
     * <p>
     *
     * @param whileNode whileNode to translate
     * @return ByteCode representing the procedureCall node and subsequent nodes
     * @throws IOException on translations failure
     * @implNote for simplicity:<br>
     * Instead of resolving the condition we rely on binary-operation translation to take care of conditions (puts 1/0 on stack).<br>
     * We check if the stack holds value 1 and jump into the correct branch<br>
     * This approach also allows us to check the truthiness of a variable/value but adds unnecessary complexity for simple while conditions.<br>
     * </p>
     */
    private byte[] toByteCode(Node.WhileNode whileNode) throws Exception {
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();

        // Determine the conditioned branch to get it's size
        byte[] whileBranch = toByteCode(whileNode.getLeft());

        // Add the constant 0 onto the stack (value we compare against, inverted -> if true we go out of the branch)
        outputStream.write(ByteCode.ICONST_0.getCode());
        incrementStackSize(1);

        // resolve the condition (this should put a value onto the stack)
        byte[] conditionCode = toByteCode(whileNode.getCondition());
        outputStream.write(conditionCode);

        // compare value
        outputStream.write(ByteCode.IF_ICMPEQ.getCode());

        // Decrement stack by 2, both arguments used
        decrementStackSize(2);

        // Write jump offset (skip else branch)
        short elseBranchSize = (short) (whileBranch.length + 3 + 3); // + ifcmp + goto
        outputStream.write(elseBranchSize >> 8);
        outputStream.write(elseBranchSize);

        // Write the conditioned statements
        outputStream.write(whileBranch);

        // Write goto back to the if Statement (negative offset)
        outputStream.write(ByteCode.GOTO.getCode());
        short offset = (short) -(whileBranch.length + 3 + 1 + conditionCode.length); // ifcmp (+ 1 from incomplete goto)
        outputStream.write(offset >> 8);
        outputStream.write(offset);

        return outputStream.toByteArray();
    }

    /**
     * Translates a ifNode into ByteCode
     * <p>
     *
     * @param ifNode ifNode to translate
     * @return ByteCode representing the procedureCall node and subsequent nodes
     * @throws IOException on translations failure
     * @implNote for simplicity:<br>
     * Instead of resolving the condition we rely on binary-operation translation to take care of conditions (puts 1/0 on stack).<br>
     * We check if the stack holds value 1 and jump into the correct branch<br>
     * This approach also allows us to check the truthiness of a variable/value but adds unnecessary complexity for simple if/else conditions.<br>
     * </p>
     */
    private byte[] toByteCode(Node.IfNode ifNode) throws Exception {
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();

        // Determine branches, such that sizes are known
        byte[] ifBranch = toByteCode(ifNode.getLeft());
        byte[] elseBranch = toByteCode(ifNode.getRight());

        // Add the constant 0 onto the stack (value we compare against)
        outputStream.write(ByteCode.ICONST_0.getCode());
        incrementStackSize(1);

        // resolve the condition (this should put a value onto the stack)
        outputStream.write(toByteCode(ifNode.getCondition()));

        // compare value
        outputStream.write(ByteCode.IF_ICMPNE.getCode());

        // Decrement stack by 2, both arguments used
        decrementStackSize(2);

        // Write jump offset (skip else branch)
        short elseBranchSize = (short) (elseBranch.length + 3 + 3); // + ifcmp + goto
        outputStream.write(elseBranchSize >> 8);
        outputStream.write(elseBranchSize);

        // Write else branch
        outputStream.write(elseBranch);

        // Jump over if branch
        outputStream.write(ByteCode.GOTO.getCode());
        short ifBranchSize = (short) (ifBranch.length + 3); // goto
        outputStream.write(ifBranchSize >> 8);
        outputStream.write(ifBranchSize);

        // Write if branch
        outputStream.write(ifBranch);

        return outputStream.toByteArray();
    }

    /**
     * Translates a binaryOperationNode into ByteCode
     *
     * @param binaryOperationNode binaryOperationNode to translate
     * @return ByteCode representing the procedureCall node and subsequent nodes
     * @throws IOException on translations failure
     * @implNote comparisons are implemented using ifcmp. They put the resulting value onto the stack.
     */
    private byte[] toByteCode(Node.BinaryOperationNode binaryOperationNode) throws Exception {
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();

        Operation.Binary operation = binaryOperationNode.getOperation();

        // Translate assignment
        if (operation == Operation.Binary.ASSIGNMENT) {

            // Get variable being assigned
            Objekt.Parameter assignee = (Objekt.Parameter) ((Node.IdentifierNode) binaryOperationNode.getLeft()).getSymbolTableEntry();

            // Store value, differentiate between local variable and static class variable
            if (localVariableIndices.contains(assignee)) {
                // resolve assignment
                outputStream.write(toByteCode(binaryOperationNode.getRight()));

                // Reference local variable via index (+1 offset objectReference)
                outputStream.write(ByteCode.ISTORE.getCode());
                outputStream.write(localVariableIndices.indexOf(assignee) + 1);
            } else {
                // Load object reference
                outputStream.write(ByteCode.ALOAD_0.getCode());
                incrementStackSize(1);

                // resolve assignment
                outputStream.write(toByteCode(binaryOperationNode.getRight()));

                // put class variable and constant pool reference
                outputStream.write(ByteCode.PUTFIELD.getCode());
                outputStream.write(constantPool.getByReference(assignee) >> 8);
                outputStream.write(constantPool.getByReference(assignee));

                // remove aload reference
                decrementStackSize(1);
            }

            // Remove stored value from stack counter
            decrementStackSize(1);
            return outputStream.toByteArray();
        }


        Node left = binaryOperationNode.getLeft();
        Node right = binaryOperationNode.getRight();

        // Resolve left&right part of the expression (expression leave their value on the stack)
        outputStream.write(toByteCode(left));
        outputStream.write(toByteCode(right));

        // Write operation
        switch (operation) {
            case ADDITION -> outputStream.write(ByteCode.IADD.getCode());
            case SUBTRACTION -> outputStream.write(ByteCode.ISUB.getCode());
            case MULTIPLICATION -> outputStream.write(ByteCode.IMUL.getCode());
            case DIVISION -> outputStream.write(ByteCode.IDIV.getCode());
            case EQUAL -> outputStream.write(ByteCode.IF_ICMPEQ.getCode());
            case LESS -> outputStream.write(ByteCode.IF_ICMPLT.getCode());
            case LESS_EQUAL -> outputStream.write(ByteCode.IF_ICMPLE.getCode());
            case GREATER -> outputStream.write(ByteCode.IF_ICMPGT.getCode());
            case GREATER_EQUAL -> outputStream.write(ByteCode.IF_ICMPGE.getCode());
        }

        if (operation == Operation.Binary.EQUAL ||
                operation == Operation.Binary.LESS ||
                operation == Operation.Binary.LESS_EQUAL ||
                operation == Operation.Binary.GREATER ||
                operation == Operation.Binary.GREATER_EQUAL) {
            // Write the result to the stack

            // jump-offset 1 if condition true
            outputStream.write(0x00);
            outputStream.write(0x07);

            // default case (write 0) goto next (skip write 1)
            outputStream.write(ByteCode.ICONST_0.getCode());
            outputStream.write(ByteCode.GOTO.getCode());
            outputStream.write(0x00);
            outputStream.write(0x04);

            // jumped case (write 1)
            outputStream.write(ByteCode.ICONST_1.getCode());
        }

        // Result of binary operation is a single value
        decrementStackSize(1);

        return outputStream.toByteArray();
    }


    /**
     * Translates a identifierNode into ByteCode
     *
     * @param identifierNode identifierNode to translate
     * @return ByteCode representing the procedureCall node and subsequent nodes
     */
    private byte[] toByteCode(Node.IdentifierNode identifierNode) throws Exception {
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();

        // Translate constant (constant values within the code)
        if (identifierNode.getSymbolTableEntry() instanceof Objekt.Constant) {
            Objekt.Constant constant = (Objekt.Constant) identifierNode.getSymbolTableEntry();

            incrementStackSize(1);
            return loadConstant(constant.getValue());
        }

        // Translate variables (load variable value onto stack)
        if (identifierNode.getSymbolTableEntry() instanceof Objekt.Parameter) {
            Objekt.Parameter variable = (Objekt.Parameter) identifierNode.getSymbolTableEntry();

            // Differentiate between local & global variables
            if (localVariableIndices.contains(variable)) {
                // Reference local variable via index (+1 offset objectReference)
                outputStream.write(ByteCode.ILOAD.getCode());
                outputStream.write(localVariableIndices.indexOf(variable) + 1);
            } else {
                // Load object reference
                outputStream.write(ByteCode.ALOAD_0.getCode());
                incrementStackSize(1);
                // get variable via get field and constant pool reference
                outputStream.write(ByteCode.GETFIELD.getCode());
                int index = constantPool.getByReference(variable); // get index from pool
                outputStream.write(index >> 8);
                outputStream.write(index);
                decrementStackSize(1);
            }
            incrementStackSize(1);
        }
        return outputStream.toByteArray();
    }

    /**
     * Loads a constant onto the stack using the correct operation
     *
     * @param constant constant to load
     * @return ByteCode loading the constant
     */
    private byte[] loadConstant(int constant) {
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();

        // Use BIPUSH if it's sufficient
        if (constant < 127 && constant > -127) {
            outputStream.write(ByteCode.BIPUSH.getCode());
            outputStream.write(constant);
            return outputStream.toByteArray();
        }

        // Use SIPUSH if it's sufficient
        if (constant < 32767 && constant > -32767) {
            outputStream.write(ByteCode.SIPUSH.getCode());
            outputStream.write(constant >> 8);
            outputStream.write(constant);
            return outputStream.toByteArray();
        }

        // Find constant index within constant pool
        int constantIndex = constantPool.constantReference.get(constant);

        // Push the constant value onto the stack
        outputStream.write(ByteCode.LDC.getCode());
        outputStream.write(constantIndex);
        return outputStream.toByteArray();
    }
}
